#
#   Copyright 2022 Logical Clocks AB
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
from __future__ import annotations

import json
from typing import TYPE_CHECKING, Any, Literal

from hopsworks_apigen import public


if TYPE_CHECKING:
    import great_expectations

import humps
from hsfs import util
from hsfs.core.constants import HAS_GREAT_EXPECTATIONS
from hsfs.decorators import uses_great_expectations
from hsfs.ge_validation_result import ValidationResult


if HAS_GREAT_EXPECTATIONS:
    import great_expectations


@public
class ValidationReport:
    """Metadata object representing a validation report generated by Great Expectations in the Feature Store."""

    def __init__(
        self,
        success: bool,
        results: list[
            ValidationResult
            | dict[str, Any]
            | great_expectations.core.expectation_validation_result.ExpectationValidationResult
        ],
        meta: dict[str, Any] | str | None,
        statistics: dict[str, Any] | str | None,
        evaluation_parameters: dict[str, Any] | str | None = None,
        id: int | None = None,
        full_report_path: str | None = None,
        featurestore_id: int | None = None,
        featuregroup_id: int | None = None,
        validation_time: str | None = None,
        ingestion_result: Literal[
            "ingested", "rejected", "unknown", "experiment", "fg_data"
        ] = "unknown",
        **kwargs,
    ) -> None:
        self._id = id
        self._success = success
        self._full_report_path = full_report_path
        self._validation_time = validation_time
        self._featurestore_id = featurestore_id
        self._featuregroup_id = featuregroup_id
        self._ingestion_result = ingestion_result

        self.results = results
        self.meta = meta
        self.statistics = statistics
        self.evaluation_parameters = evaluation_parameters

    @classmethod
    def from_response_json(
        cls, json_dict: dict[str, Any]
    ) -> list[ValidationReport] | ValidationReport:
        json_decamelized = humps.decamelize(json_dict)
        if (
            "count" in json_decamelized
        ):  # todo it has count either way (if items or dict)
            if json_decamelized["count"] == 0:
                return []
            return [
                cls(**validation_report)
                for validation_report in json_decamelized["items"]
            ]
        return cls(**json_decamelized)

    def json(self) -> str:
        return json.dumps(self, cls=util.Encoder)

    def to_dict(self) -> dict[str, int | str | bool]:
        return {
            "id": self._id,
            "success": self.success,
            "evaluationParameters": json.dumps(self.evaluation_parameters),
            "statistics": json.dumps(self._statistics),
            "results": self._results,
            "meta": json.dumps(self._meta),
            "ingestionResult": self._ingestion_result.upper(),
        }

    @public
    def to_json_dict(self) -> dict[str, Any]:
        return {
            "id": self._id,
            "success": self.success,
            "evaluationParameters": self.evaluation_parameters,
            "statistics": self._statistics,
            "results": [result.to_json_dict() for result in self._results],
            "meta": self._meta,
        }

    @public
    @uses_great_expectations
    def to_ge_type(self) -> great_expectations.core.ExpectationSuiteValidationResult:
        """Convert to Great Expectations ExpectationSuiteValidationResult type."""
        return great_expectations.core.ExpectationSuiteValidationResult(
            success=self.success,
            statistics=self.statistics,
            results=[result.to_ge_type() for result in self.results],
            evaluation_parameters=self.evaluation_parameters,
            meta=self.meta,
        )

    @public
    @property
    def id(self) -> int | None:
        """Id of the validation report, set by backend."""
        return self._id

    @id.setter
    def id(self, id: int | None) -> None:
        self._id = id

    @public
    @property
    def success(self) -> bool:
        """Overall success of the validation step."""
        return self._success

    @success.setter
    def success(self, success: bool) -> None:
        self._success = success

    @public
    @property
    def results(self) -> list[ValidationResult]:
        """List of expectation results obtained after validation."""
        return self._results

    @results.setter
    def results(
        self,
        results: list[
            ValidationResult
            | dict[str, Any]
            | great_expectations.core.expectation_validation_result.ExpectationValidationResult
        ],
    ) -> None:
        if len(results) == 0:
            self._results = []
        elif isinstance(results[0], ValidationResult):
            self._results = results
        elif isinstance(results[0], dict):
            self._results = [ValidationResult(**result) for result in results]
        elif isinstance(
            results[0],
            great_expectations.core.expectation_validation_result.ExpectationValidationResult,
        ):
            self._results = [
                ValidationResult(**result.to_json_dict()) for result in results
            ]

    @public
    @property
    def meta(self) -> dict[str, Any] | None:
        """Meta field of the validation report to store additional informations."""
        return self._meta

    @meta.setter
    def meta(self, meta: dict[str, Any] | str | None) -> None:
        if meta is None:
            self._meta = None
        elif isinstance(meta, dict):
            self._meta = meta
        elif isinstance(meta, str):
            self._meta = json.loads(meta)
        else:
            raise ValueError("Meta field must be stringified json or dict.")

    @public
    @property
    def statistics(self) -> dict[str, Any] | None:
        """Statistics field of the validation report which store overall statistics about the validation result, e.g number of failing/successful expectations."""
        return self._statistics

    @statistics.setter
    def statistics(self, statistics: str | dict[str, Any] | None) -> None:
        if statistics is None:
            self._statistics = None
        elif isinstance(statistics, dict):
            self._statistics = statistics
        elif isinstance(statistics, str):
            self._statistics = json.loads(statistics)
        else:
            raise ValueError("Statistics field must be stringified json or dict")

    @public
    @property
    def evaluation_parameters(self) -> dict[str, Any] | None:
        """Evaluation parameters field of the validation report which store kwargs of the validation."""
        return self._evaluation_parameters

    @evaluation_parameters.setter
    def evaluation_parameters(
        self, evaluation_parameters: dict[str, Any] | str | None
    ) -> None:
        if evaluation_parameters is None:
            self._evaluation_parameters = None
        elif isinstance(evaluation_parameters, dict):
            self._evaluation_parameters = evaluation_parameters
        elif isinstance(evaluation_parameters, str):
            self._evaluation_parameters = json.loads(evaluation_parameters)
        else:
            raise ValueError(
                "Evaluation parameters field must be stringified json or dict"
            )

    @public
    @property
    def ingestion_result(self) -> str:
        """Overall success of the validation run together with the ingestion validation policy, indicating if dataframe was ingested or rejected."""
        return self._ingestion_result

    @ingestion_result.setter
    def ingestion_result(
        self,
        ingestion_result: Literal[
            "ingested", "rejected", "experiment", "unknown", "fg_data"
        ]
        | None,
    ) -> None:
        if ingestion_result is None:
            ingestion_result = "UNKNOWN"
        allowed_values = ["ingested", "rejected", "experiment", "unknown", "fg_data"]
        if ingestion_result.lower() in allowed_values:
            self._ingestion_result = ingestion_result
        else:
            raise ValueError(
                f"Invalid Value {ingestion_result} for ingestion_result."
                f"Allowed values are {', '.join(allowed_values)}."
            )

    def __str__(self) -> str:
        return self.json()

    def __repr__(self) -> str:
        return (
            f"ValidationReport(success: {self._success}, "
            f"{self._statistics}, {len(self._results)} results"
            f" , {self._meta}, {self._full_report_path})"
        )
